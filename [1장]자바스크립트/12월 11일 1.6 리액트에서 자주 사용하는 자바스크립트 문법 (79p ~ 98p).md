요약 : 박운성

- **리액트에서 자주 사용하는 자바스크립트 문법** (79p ~ 80p)
  - **리액트 코드**의 **독특한 특징**을 이해하려면 ?
    - **리액트**에서 자주 사용되는 **자바스크립트**(이하 **JS**) 문법을 이해해야 함
    - **JS** 문법을 이해한다면 **리액트**가 어떻게 작동하는지도 이해할 수 있음
  - **JS**는 매년 새로운 버전과 함께 새로운 기능이 나옴
    - 이러한 **JS** 표준을 **ECMAScript**라고 함 (이하 **ES**)
  - 작성하고자 하는 **JS** 문법이 어느 **ES** 버전에서 만들어졌는지도 파악해야 함
    - 모든 브라우저와 **JS** 런타임이 항상 최신 **JS** 문법을 지원하는 것이 아니기 때문
      ex) **인터넷 익스플로러 11**은 **ES5**까지만 지원
    - 다양한 브라우저에서의 문법 지원 또한 염두에 두어야함
      ex) **크롬**, **사파리**, **파이어폭스** 등
  - **바벨**
    - 사용자의 다양한 브라우저 환경과 최신 문법을 작성하고 싶은 개발자의 요구를 해결하기 위해 탄생
    - JS의 최신 문법을 다양한 브라우저에서도 일관적으로 지원할 수 있도록 코드를 트랜스파일
    - 바벨이 어떻게 최신 코드를 트랜스파일하고, 그 결과 어떤 코드가 생성되는지 이해하면 향후 애플리케이션을 디버깅하는 데 도움
- **구조 분해 할당** (80p ~ 87p)
  - **구조 분해 할당 (Destructuring assignment)**
    - 배열 또는 객체의 값을 말 그대로 분해해 개별 변수에 즉시 할당하는 것
    - **배열 구조 분해 할당**은 **ES6(ECMA2015)**에서 등장
    - **객체 구조 분해 할당**은 **ECMA** 2018에서 등장
  - **배열 구조 분해 할당**
    - **useState**에서 많이 본 형식의 코드
      ```jsx
      const array = [1, 2, 3, 4, 5];

      const [first, second, third, ...arrayRest] = array;
      // first 1
      // second 2
      // third 3
      // arrayRest [4, 5]
      ```
    - **useState**가 배열을 반환하는 이유는?
      - **배열 구조 분해 할당**은 **객체 구조 분해 할당**에 비해 자유롭게 이름을 선언할 수 있기 때문인 것으로 추측할 수 있음
    - **배열** **구조 분해 할당**은 콤마(,)의 위치에 따라 값이 결정
      ```jsx
      const array = [1, 2, 3, 4, 5];
      const [first, , , , fifth] = array;
      // 2, 3, 4는 아무런 표현식이 없으므로 변수 할당이 생략

      first; // 1
      fifth; // 5

      // 이 방법은 실수를 유발할 가능성이 커서
      // 배열의 길이가 작을 때 주로 쓰임
      ```
    - **배열 구조 분해 할당**에는 기본값 선언 가능
      ```jsx
      const array = [1, 2];
      const [a = 10, b = 10, c = 10] = array;
      // a 1
      // b 2
      // c 10
      ```
    - **주의할 점**
      - **undefined**일 때만 기본값을 사용
        ```jsx
        const [a = 1, b = 1, c = 1, d = 1, e = 1] = [undefined, null, 0, ""];
        a; // 1
        b; // null
        c; // 0
        d; // ''
        e; // 1
        ```
  - **객체 구조 분해 할당**
    - **배열 구조 분해 할당**과 차이점은 객체는 객체 내부 이름으로 꺼내온다는 것
      ```jsx
      const obj = {
        a: 1,
        b: 2,
        c: 3,
        d: 1,
        e: 1,
      };

      const { a, b, c, ...objRest } = obj;
      // a 1
      // b 2
      // c 3
      // objRest = {d: 1, e:1}
      ```
    - 새로운 이름으로 다시 할당하는 것 또한 가능
      ```jsx
      const obj = {
        a: 1,
        b: 2,
      };

      const { a: first, b: second } = obj;
      // first 1
      // second 2
      ```
    - 기본값을 주는 것도 가능
      리액트 컴포넌트인 props에서 값을 바로 꺼내올 때 매우 자주 쓰는 방식
      ```jsx
      function sample({ a, b }) {
        return a + b;
      }

      sample({ a: 3, b: 5 }); // 8
      ```
    - 변수에 있는 값으로 꺼내오는 **계산된 속성 이름 방식**도 가능
      ```jsx
      const k = "a";
      const ob = {
        a: 1,
        b: 1,
      };

      const { [k]: a } = ob;
      // a = 1

      const { [k]: a } = ob; // Uncaught SuntaxError: Unexpected token '['
      ```
      - 이러한 계산된 속성 이름을 사용하려면 반드시 이름을 선언하는 :a와 같은 변수 네이밍이 필요
        - 계산된 이름인 [k]로 값을 꺼내기만 하고 어느 변수명으로 할당해야 할지 알 수 없기 때문
  - **바벨**
    - 배열의 경우에는 트랜스파일을 거쳤을 때 간단한 편
    - 객체의 경우 트랜스파일을 거치면 번들링 크기가 **상대적으로 크기 때문에** **ES5**를 고려해야 하고, **객체 구조 분해 할당**을 **자주 쓰지 않는다면** 꼭 써야하는지 검토할 필요가 있음
    - 외부 라이브러리를 사용해 보는 것도 고려해 볼 만함
- **전개 구문** (87p ~ 91p)
  - **전개 구문 (Spread Syntax)**
    - 배열이나 객체, 문자열과 같이 순회할 수 있는 값에 대해 전개해 간결하게 사용할 수 있는 구문
    - **배열 전개 구문**은 **ES6(ES2015)**에서 등장
    - **객체 전개 구문**은 **ECMA2018**에서 등장
  - **배열 전개 구문**
    ```jsx
    const a1 = ["a", "b"];
    const a2 = [...a1, "c", "d", "e"]; // ['a', 'b', 'c', 'd', 'e']
    ```
    - 배열 내부에서 **…배열**을 사용하면 기존 배열에 영향을 미치지 않고 배열을 복사 가능
    ```jsx
    const a1 = ["a", "b"];
    const a2 = a1;

    a1 === a2; // true. 내용이 아닌 참조를 복사하기 때문

    const a1 = ["a", "b"];
    const a2 = [...a1];

    a1 === a2; // false. 값만 복사되고 참조는 다르므로 false 반환
    ```
  - **객체 전개 구문**
    - 배열과 비슷하게 사용 가능
      ```jsx
      const o1 = {
        a: 1,
        b: 2,
      };

      const o2 = {
        c: 3,
        d: 4,
      };

      const no = { ...o1, ...o2 }; // { "a": 1, "b": 2, "c": 3, "d": 4 }
      ```
    - 객체 전개 구문은 순서가 중요
      - 위에 있을 때와 아래에 있을 때의 작동 순서 차이로 전혀 다른 객체가 생성될 수 있음
      ```jsx
      const o = {
        a: 1,
        b: 2,
        c: 3,
        d: 4,
        e: 5,
      };

      const aO = {
        ...o,
        c: 10,
      };
      // {a: 1, b: 2, c: 10, d: 4, e: 5 }

      const bO = {
        c: 10,
        ...o,
      };
      // {a: 1, b: 2, c: 3, d: 4, e: 5 }
      ```
  - **바벨**
    - 배열의 경우 **`concat()`** 메소드로 트랜스파일
    - 객체의 경우 **객체 구조 분해 할당**을 트랜스파일한 결과와 비슷한 차이
- **객체 초기자** (92p ~ 93p)
  - **객체 초기자(object shorthand assignment)**
    - **ECMA2015**에 도입된 기능
    - 객체에 넣어야 할 키와 값을 가지고 있는 변수가 이미 존재하면 해당 값을 간결하게 넣어줄 수 있는 방식
    - **예시 코드**
      ```jsx
      const a = 1;
      const b = 2;

      const o = {
        a,
        b,
      };
      // {a: 1, b: 2}
      ```
  - **바벨**
    ```jsx
    // before
    const a = 1;
    const b = 2;

    const o = {
      a,
      b,
    };

    // after

    var a = 1;
    var b = 2;
    var o = {
      a: a,
      b: b,
    };
    ```
- **Array 프로토타입의 메소드: map, filter, reduce, forEach** (93p ~ 96p)
  - **Array.prototype.map**
    - 인수로 전달받은 배열과 똑같은 길이의 새로운 배열 반환
    - 배열의 각 아이템을 순회하면서 각 아이템을 콜백으로 연산한 결과로 구성된 새로운 배열을 만들 수 있음
    ```jsx
    const arr = [1, 2, 3, 4, 5];
    const doubleArr = arr.map((item) => item * 2);
    // 2 4 6 8 10
    ```
    - 리액트에서의 사용 예시 코드
      ```jsx
      const arr = [1, 2, 3, 4, 5];
      const El = arr.map((item) => {
        return <Fragment key={item}>{item}</Fragment>;
      });
      ```
  - **Array.prototype.filter**
    - 인수로 받은 콜백 함수에서 **truthy** 조건을 만족하는 경우에만 해당 원소를 반환
    - 주로 기존 배열에 대해 어떠한 조건을 만족하는 새로운 배열을 반환할 때 쓰임
    ```jsx
    const arr = [1, 2, 3, 4, 5];
    const evenArr = arr.filter((item) => item % 2 === 0);
    // [2, 4]
    ```
  - **Array.prototype.reduce**
    - **콜백 함수**와 함께 **초깃값**을 인수로 받음
    - **초깃값**에 따라 배열이나 객체, 그 외의 다른 무언가를 반환할 수 있는 메소드
    - **reducer 콜백 함수**를 실행하고, 이를 초깃값에 누적해 결과를 반환
      ```jsx
      const arr = [1, 2, 3, 4, 5];
      const sum = arr.reduce((result, item) => {
        return result + item;
      }, 0);
      // 15
      ```
      - 0은 **reduce**의 결과를 누적할 초깃값
      - **reducer 콜백 함수**의 첫 번째 인수는 앞서 선언한 **초깃값**의 **현재값**
      - 두 번째 인수는 **현재 배열의 아이템**
    - **reduce**는 배열을 원하는 객체로 변환하는 등 다양한 예제에서 사용
  - **Array.prototype.forEach**
    - **콜백 함수**를 받아 배열을 순회하면서 **콜백 함수**를 실행하는 메소드
    ```jsx
    const arr = [1, 2, 3];

    arr.forEach((item) => console.log(item));
    // 1, 2, 3
    ```
    - **주의할 점**
      - **forEach**는 아무런 **반환값이 없음 (undefined)**
      - 실행되는 순간 에러를 던지거나 프로세스를 종료하지 않는 한 **멈출 수 없음**
        ```jsx
        function run() {
          const arr = [1, 2, 3];
          arr.forEach((item) => {
            console.log(item);
            if (item === 1) {
              console.log("finished!");
              return;
            }
          });
        }

        run();

        // 1
        // finished
        // 2
        // 3
        ```
        - 중간에 **return**이 존재해 **함수 실행이 끝났음에도** 불구하고 계속해서 **forEach 콜백**이 실행
        - 이는 **return**이 **함수의** **return**이 아닌 **콜백 함수의** **return**으로 간주되기 때문
- **삼항 조건 연산자** (96p ~ 97p)
  - **JS**에서 유일하게 3개의 피연산자를 취할 수 있는 문법
    - **맨 앞에** **조건문**이 들어가고 **그 이후 물음표**가 들어감
    - **물음표 뒤**에는 **참일 경우 반환할 값**, **콜론(:) 뒤**에는 **거짓일 때 반환할 값**
    ```jsx
    조건문 ? 참일_때_값 : 거짓일_때_값;

    const v = 10;
    const r = v % 2 === 0 ? "짝수" : "홀수";
    // 짝수
    ```
  - **리액트**에서는 **JSX** 내부에서 **조건부로 렌더링**하기 위해서 자주 쓰임
    ```jsx
    function Component({ condition }) {
      return <>{condition ? "참" : "거짓"}</>;
    }
    ```
    - **삼항 조건 연산자 내부**에 또다시 **삼항 연산자를 중첩해서 쓰는 경우**가 종종 발생
      ```jsx
      const { useMemo } = require("react");

      const v = useMemo(
        () => (condition1 ? "1" : condition2 ? "2" : condition3 ? "3" : "else"),
        [condition1, condition2, condition3]
      );
      ```
      - **결과를 예측하기가 어려우므로** **삼항 연산자**는 가급적이면 **중첩해서 쓰지 않는 편**이 좋음
- **정리**
  - 최신 **JS** 문법에 관심이 많다면 **ECMAScript**의 신규 문법을 제안하는 [\*\*저장소](https://github.com/tc39/proposals)\*\* 참조
