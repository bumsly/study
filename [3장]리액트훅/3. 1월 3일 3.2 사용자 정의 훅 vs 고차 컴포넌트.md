요약 : 박운성

# 3.2 사용자 정의 훅 vs 고차 컴포넌트

## **3.2.1 사용자 정의 훅**

### **사용자 정의 훅이란? (이하 커스텀 훅)**

- 리액트에서만 사용할 수 있는 방식으로 3.1절에서 소개한 훅을 기반으로 개발자가 필요한 훅을 만드는 기법입니다.
- 서로 다른 컴포넌트 내부에서 같은 로직을 공유하고자 할 때 주로 사용됩니다.

### **커스텀 훅의 규칙**

- 이름이 반드시 use로 시작하는 함수를 만들어야 합니다.
- 리액트 훅의 이름은 use로 시작한다는 규칙이 있으며, 커스텀 훅도 이 규칙을 준수함으로써 해당 함수가 리액트 훅이라는 것을 바로 인식할 수 있다는 장점이 있습니다.

### **HTTP 요청을 하는 fetch를 기반으로 한 커스텀 훅 예제**

[code_3-29](https://codesandbox.io/p/sandbox/code-3-29-3rt3tl?file=/src/App.tsx:19,45)

- 위 코드를 훅으로 분리하지 않았다면 API 호출을 하는 모든 컴포넌트 내에서 최소 4개의 state를 선언해서 각각 구현했어야 할 것입니다.
- useReducer를 사용해 최적화해도 useEffect도 필요하기 때문에 두 가지 훅을 fetch가 필요한 곳마다 중복 사용 해야합니다.
- 두 가지 훅을 사용한 로직을 커스텀 훅 내부에 두면 사용하는 쪽에서는 커스텀 훅만 사용해도 중복되는 로직을 손쉽게 관리할 수 있습니다.

### **왜 use 라는 이름을 지켜야 하는가?**

- 커스텀 훅은 내부에 리액트 훅을 사용하고 있기 때문에 리액트 훅의 규칙을 따라야 합니다.
- react-hooks/rules-of-hooks의 도움을 받기 위해서는 use로 시작하는 이름을 가져야 하며 그렇지 않으면 훅은 함수형 컴포넌트 내부 또는 커스텀 훅 내부에서만 사용할 수 있다는 에러가 발생합니다.

- **경고를 제거하는 방법**
  - 이름 fetch의 앞부분을 대문자로 바꿔 함수형 컴포넌트 라고 알리는 방법
  - use를 앞에 붙여 커스텀 훅이라고 알리는 방법

### **다양한 커스텀 훅이 저장된 리액트 커뮤니티**

- [**use-Hooks**](https://github.com/uidotdev/usehooks)
- **[react-use](https://github.com/streamich/react-use)**
- **[ahooks](https://github.com/alibaba/hooks)**
- 필요한 기능이 있다면 도움을 구할 수도 있고, 각 훅을 살펴보면서 어떤 식으로 구현돼 있는지 살펴보는 것도 리액트를 공부하는 데 많은 도움이 될 것입니다.

## **3.2.2 고차 컴포넌트**

### **고차 컴포넌트 (HOC, Higer Order Component)**

- 컴포넌트 자체의 로직을 재사용하기 위한 방법입니다.
- 리액트에서는 이러한 고차 컴포넌트 기법으로 다양한 최적화나 중복 로직 관리를 할 수 있습니다.
- 커스텀 훅은 리액트 훅을 기반으로 하므로 리액트에서만 사용 가능한 기술이지만 고차 컴포넌트는 고차 함수 (Higher Order Function)의 일종으로, 자바스크립트의 일급 객체, 함수의 특징을 이용하므로 리액트가 아니더라도 자바스크립트 환경에서 널리 쓰일 수 있습니다.

### **React.memo란?**

- 부모 컴포넌트가 새롭게 렌더링될 때, 자식 컴포넌트는 자신의 props 변경 여부와 관계없이 리렌더링이 발생합니다.
- 위 경우처럼 props의 변화가 없을 때 컴포넌트의 렌더링을 방지하기 위해 만들어진 고차 컴포넌트가 React.memo 입니다.
- React.memo는 렌더링하기 전에 props를 비교해 이전과 같다면 렌더링 자체를 생략하고 기억해 둔 (memoization) 컴포넌트를 반환합니다.
- 이 방식은 앞서 클래스형 컴포넌트에서 소개했던 PureComponent와 매우 유사하다고 볼 수 있습니다.

### **useMemo를 사용해도 동일하게 메모이제이션할 수 있지 않을까?**

- useMemo를 사용할 경우 값을 반환받기 때문에 JSX 함수 방식이 아닌 {}을 사용한 할당식을 사용한다는 차이점이 있습니다.
- 코드를 작성하고 리뷰하는 입장에선 혼선을 빚을 수 있으므로 필요한 경우가 아니면 목적과 용도가 뚜렷한 React.memo를 사용하는 편이 좋습니다.

### **고차 함수 만들어보기**

- 리액트의 함수형 컴포넌트도 함수이기 때문에 함수를 기반으로 고차 함수를 만드는 것을 먼저 이해해야 합니다.
- 고차 함수의 사전적 정의: 함수를 인수로 받거나 결과로 반환하는 함수
- 가장 대표적인 고차 함수: Array.prototype.map
- 예제

  ```tsx
  function add(a) {
    return function (b) {
      return a + b;
    };
  }

  const result = add(1); // 여기서 result는 앞서 반환한 함수를 가리킨다. function (b) { return a=1 + b; }
  const result2 = result(2); // 비로소 a와 b를 더한 3이 반환된다.
  ```

  - add(1) 함수를 호출하는 시점에 1이라는 정보가 a에 포함되고, 이러한 정보가 담긴 함수를 result로 반환합니다.
  - 이것은 useState의 원리와 비슷합니다.
  - useState의 실행은 함수 호출과 동시에 끝났지만 state의 값은 별도로 선언한 환경, 즉 클로저에 기억됩니다.
  - 여기에서도 마찬가지로 a=1이라는 정보가 담긴 클로저가 result에 포함됐고, result(2)를 호출하면서 이 클로저에 담긴 a=1인 정보를 활용해 1+2의 결과를 반환할 수 있게 됐습니다.

- 고차 함수를 활용하면 함수를 인수로 받거나 새로운 함수를 반환해 완전히 새로운 결과를 만들어 낼 수 있습니다.
- 리액트의 함수형 컴포넌트도 함수이므로 고차 함수를 사용하면 다양한 작업을 할 수 있습니다.

### **고차 함수를 활용한 리액트 고차 컴포넌트 만들어보기**

- 사용자 인증 정보에 따라 인증된 사용자와 그렇지 않은 사용자에게는 각각 다른 컴포넌트를 보여주는 시나리오에서 고차 함수의 특징에 따라 또 다른 함수를 반환할 수 있다는 점에서 고차 컴포넌트를 사용하면 매우 유용합니다.
- [**예제**](https://codesandbox.io/p/sandbox/exhoc-9f5jhp?file=%2Fsrc%2FApp.tsx%3A6%2C2)
  - Component는 평범한 함수형 컴포넌트지만, 이 함수 자체를 withLoginComponent라 불리는 고차 컴포넌트로 감싸뒀습니다.
  - withLoginComponent는 함수(함수형 컴포넌트)를 인수로 받으며, 컴포넌트를 반환하는 고차 컴포넌트입니다.
  - 이 컴포넌트는 props에 loginRequired가 있다면 넘겨받은 함수를 반환하는 것이 아니라 "로그인이 필요합니다" 라는 전혀 다른 결과를 반환합니다.
- 고차 컴포넌트는 컴포넌트 전체를 감쌀 수 있다는 점에서 컴포넌트에 커스텀 훅보다 더욱 큰 영향력을 미칠 수 있습니다.
- 단순히 값을 반환하거나 부수 효과를 실행하는 커스텀 훅과는 다르게, 고차 컴포넌트는 컴포넌트의 결과물에 영향을 미칠 수 있는 다른 공통된 작업을 처리할 수 있습니다.

### **고차 컴포넌트 구현 시 주의할 점**

- 리액트의 고차 컴포넌트는 with로 시작하는 이름을 사용해야 합니다.
  - 리액트 커뮤니티에 널리 퍼진 일종의 관습이라고 볼 수 있습니다.
  - with가 접두사로 붙어있으면 고차 컴포넌트임을 손쉽게 알아채어 개발자 스스로가 컴포넌트 사용에 주의를 기울일 수 있으므로 반드시 with로 시작하는 접두사로 고차 컴포넌트를 만듭시다.
- 부수 효과를 최소화해야 합니다.
  - 고차 컴포넌트는 컴포넌트를 인수로 받게 되는데, 반드시 컴포넌트의 props를 임의로 수정, 추가, 삭제하는 일은 없어야 합니다.
  - 만약 기존 컴포넌트에서 사용하는 props를 수정하거나 삭제한다면 이는 컴포넌트를 이용하는 입장에서 예측하지 못한 상황에서 props가 변경될지도 모른다는 사실을 계속 염두에 둬야 하는 부담감을 주게 됩니다.
  - 만약 컴포넌트에 무언가 추가적인 정보를 제공해 줄 목적이라면 별도 props로 내려주는 것이 좋습니다.
- 여러 개의 고차 컴포넌트로 컴포넌트를 감쌀 경우 복잡성이 커진다는 것입니다.
  ```tsx
  const Component = withHOC1(
    withHOC2(
      withHOC3(
        withHOC4(
          withHOC5(() => {
            return <>안녕하세요.</>;
          })
        )
      )
    )
  );
  ```
  - 고차 컴포넌트가 컴포넌트를 또 다른 컴포넌트로 감싸는 구조로 되어 있어서 여러 개의 고차 컴포넌트가 반복적으로 감쌀 경우 복잡성이 매우 커집니다.
  - 고차 컴포넌트가 증가할수록 개발자는 결과를 예측하기 어려워지므로, 고차 컴포넌트는 최소한으로 사용하는 것이 좋습니다.

## **3.2.3 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까?**

### **공통점**

- 리액트 코드에서 어떠한 로직을 공통화해 별도로 관리할 수 있다는 특징이 있습니다.
- 애플리케이션 전반에 필요한 중복된 로직을 별도로 분리해 컴포넌트의 크기를 줄이고 가독성을 향상시키는 데 도움을 줄 수 있습니다.

### **사용자 정의 훅이 필요한 경우**

- 리액트에서 제공하는 훅으로만 공통 로직을 격리할 수 있다면 커스텀 훅을 사용하는 것이 좋습니다.
- 단순히 컴포넌트 전반에 걸쳐 동일한 로직으로 값을 제공하거나 특정한 훅의 작동을 취하게 하고 싶다면 커스텀 훅을 사용하는 것이 좋습니다.

### **고차 컴포넌트를 사용해야 하는 경우**

- 렌더링의 결과물에도 영향을 미치는 공통 로직이라면 고차 컴포넌트를 사용하는 것이 좋습니다.
- 고차 컴포넌트는 공통화된 렌더링 로직을 처리하기에 매우 훌륭한 방법이지만, 고차 컴포넌트가 많아질수록 복잡성이 기하급수적으로 증가하므로 신중하게 사용해야 합니다.

## **3.2.4 정리**

- **공통화**하고 싶은 작업이 무엇인지, 또 현재 이를 처리해야 하는 상황을 잘 살펴보고 적절한 방법을 고른다면 애플리케이션 개발이 더 효율적으로 개선될 것입니다.
