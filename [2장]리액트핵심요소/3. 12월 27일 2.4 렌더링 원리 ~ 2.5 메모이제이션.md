요약 : 김범승

# 2.4 렌더링은 어떻게 일어나는가?

**브라우저의 렌더링**이란 HTML과 CSS 리소스를 기반으로 웹페이지에 필요한 UI를 그리는 과정.

**리액트의 렌더링**이란 브라우저가 렌더링에 필요한 DOM 트리를 만드는 과정.

리액트의 렌더링은 시간과 리소스를 소비하는데 이 비용은 모두 사용자가 부담하므로 개발자라면 렌더링의 원리를 알고 과정을 최소화함으로써 사용자 경험을 개선해야한다.

## 2.4.1 리액트의 렌더링이란?

모든 컴포넌트들이 현재 자신들이 가지고 있는 **props와 state의 값을 기반**으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정

⇒ props와 state와 같은 상태값을 가지고 있지 않다면 오직 해당 컴포넌트가 반환하는 JSX 값에 기반해 렌더링이 일어난다.

## 2.4.2 리액트의 렌더링이 일어나는 이유

렌더링 과정을 이해하는 것보다 중요한 것은 **렌더링이 언제 발생하느냐**다.

1. **최초 렌더링**
   - 브라우저가 렌더링할 초기 정보를 제공한다.
2. **리렌더링** (최초 렌더링 이후 발생하는 모든 렌더링)

   - 클래스형 컴포넌트의 setState가 실행되는 경우
     - state 업데이트 ⇒ 리렌더링
   - 클래스형 컴포넌트의 forceUpdate가 실행되는 경우
     - forceUpdate는 렌더링을 수행하는 render가 state나 props가 아닌 값에 의존하고 있어 강제로 업데이트한다. ⇒ 리렌더링
   - 함수형 컴포넌트의 useState()의 두 번째 배열 요소인 setter가 실행되는 경우
     - state 업데이트 ⇒ 리렌더링
   - 함수형 컴포넌트의 useReducer()의 두 번째 배열 요소인 dispatch가 실행되는 경우
     - 상태를 업데이트 ⇒ 리렌더링
   - 컴포넌트의 key props가 변경되는 경우
     ```jsx
     const arr [1, 2, 3];

     export default function App() {
     	return (
     		<ul>
     			{arr.map((index)) => (
     				<li key={index}>{index}</li>
     			))}
     		</ul>
     	)
     }
     ```
     key: 동일한 자식 컴포넌트가 여러 개 있는 구조에서 리렌더링이 발생했을 때 컴포넌트들을 구별하기 위한 값.
   - props가 변경되는 경우
     - 부모로부터 받는 props 업데이트 ⇒ 리렌더링
   - 부모 컴포넌트가 렌더링될 경우
     - 부모 컴포넌트가 리렌더링되면 자식 컴포넌트도 무조건 리렌더링 된다.

   > 리액트에서 렌더링이 일어나는 경우는 위의 시나리오들 뿐이다.
   > 상태 관리 라이브러리 Mobx, Redux, Recoil는 각자의 방법으로 상태를 관리해주고 위에 언급한 방법 중 하나를 사용해 리렌더링을 발생시킨다.

## 2.4.3 리액트의 렌더링 프로세스

렌더링 프로세스가 시작되면,

⇒ 업데이트가 필요하다고 지정돼있는 모든 컴포넌트 검사

⇒ **[클래스형 컴포넌트]** render()함수 실행

**[함수형 컴포넌트]** FunctionComponent() 호출 후에 결과물 저장

⇒ JSX 문법으로 된 결과물이 React.createElement()를 호출하는 구문으로 변환

⇒ 각 컴포넌트의 렌더링 결과물 수집

⇒ 실제 DOM과 가상 DOM을 비교하고 모든 변경 사항 수집 (재조정)

⇒ 모든 변경 사항을 하나의 동기 시퀀스로 DOM에 적용

## 2.4.4 렌더와 커밋

리액트의 렌더링은 렌더 단계와 커밋 단계로 분리되어 실행된다.

렌더 단계

- 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업
- type, props, key 중에 하나라도 변경된 것이 있으면 체크해둔다.

커밋 단계

- 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정

> **리액트의 렌더링이 일어난다고 무조건 DOM 업데이트가 일어나는 것은 아니다!**
> (변경 사항을 계산하는 렌더 단계에서 아무런 변경 사항이 감지되지 않았을 때)

### 동시성 렌더링

렌더와 커밋으로 이루어진 리액트의 렌더링은 항상 동기식으로 작동했지만 비동기 렌더링 또한 몇 가지 상황에서 유효할 수도 있다. 예를 들어 하나의 컴포넌트 렌더링이 무거워 상대적으로 빠르게 렌더링할 수 있는 다른 컴포넌트를 보여주는 상황이 있다.

의도된 우선순위로 컴포넌트를 렌더링해 최적화할 수 있는 비동기 렌더링, 이른바 동시성 렌더링이 리액트 18에서 도입됐다. 이는 렌더 단계가 비동기로 작동해 **특정 렌더링의 우선순위를 낮추거나, 중단하거나, 재시작하거나, 포기할 수도 있다.**

## 2.4.5 일반적인 렌더링 시나리오 살펴보기

```jsx
import { useState } from "react";

export default function A() {
  return (
    <div className="App">
      <h1>Hello React!</h1>
      <B />
    </div>
  );
}

function B() {
  const [counter, setCounter] = useState(0);

  function handleButtonClick() {
    setCounter((previous) => previous + 1);
  }

  return (
    <>
      <label>
        <C number={counter} />
      </label>
      <button onClick={handleButtonClick}>+</button>
    </>
  );
}

function C({ number }) {
  return (
    <div>
      {number} <D />
    </div>
  );
}

function D() {
  return <>리액트 재밌다!</>;
}
```

### 렌더링 순서

1. B 컴포넌트의 setState 호출된다.
2. B 컴포넌트의 리렌더링 작업이 렌더링 큐에 들어간다.
3. 리액트는 트리 최상단에서부터 렌더링 경로를 검사한다.
4. A 컴포넌트는 리렌더링이 필요한 컴포넌트로 표시돼 있지 않으므로 별다른 작업을 하지 않는다.
5. 그 다음 하위 컴포넌트인 B 컴포넌트는 업데이트가 필요하다고 체크돼 있으므로 B를 리렌더링한다.
6. 6번 과정에서 B는 C를 반환한다.
7. C는 props인 number가 업데이트 됐으므로 업데이트가 필요한 컴포넌트로 체크돼 있고 업데이트한다.
8. 7번 과정에서 C는 D를 반환했다.
9. D도 마찬가지로 업데이트가 필요한 컴포넌트로 체크되지 않았으나 C가 렌더링 됐으므로 그 자식인 D도 렌더링됐다.

# 2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

useMemo, useCallback, memo는 렌더링을 최적화 하기 위해 제공된다.

메모이제이션 최적화는 리액트 커뮤니티에서 오랜 논쟁 주제 중에 하나이다.

## 2.5.1 주장 1: 섣부른 최적화는 독이다, 꼭 필요한 곳에만 메모이제이션을 추가하자

메모이제이션도 어디까지나 비용이 드는 작업이므로 신중하게 사용해야한다.

```jsx
function sum(a, b) {
  return a + b;
}
```

- 위처럼 매우 간단한 연산을 수행하는 함수가 있다. 매번 새로운 계산을 하는 게 좋을까? 결과를 저장해두고 다시 실행될 때 메모리에서 그 값을 꺼내오는 게 좋을까?
  ⇒ 대부분의 가벼운 작업 자체는 메모이제이션 하는 것보다 매번 수행 결과를 반환하는 것이 더 빠를 수 있다.
- 렌더링 비용과 메모이제이션 비용을 비교하고 상황에 따라 적절하게 메모이제이션을 사용해야한다.

> 섣부른 최적화는 옳지 못한 행동이다. 일단 애플리케이션을 어느 정도 만든 이후에 개발자 도구나 useEffect를 사용해 실제로 어떻게 렌더링이 일어나고 있는지 확인하고 필요한 곳에서만 최적화하는 것이 옳다.

## 2.5.2 주장 2: 렌더링 과정의 비용은 비싸다, 모조리 메모이제이션해 버리자

일부 컴포넌트는 메모이제이션이 성능에 도움이 된다. 만약 해당 컴포넌트가 렌더링이 자주 일어나며 비싼 연산이 포함돼 있고, 자식 컴포넌트 또한 많이 가지고 있다면 메모이제이션이 이점을 줄 때가 분명히 있다.

### memo를 컴포넌트의 사용에 따라 잘 보고 일부만 적용할 때의 단점

- 규모가 커지고 복잡성이 증가하는 상황이라면 유지할 수 있을까?
- 개발자들은 생각보다 최적화나 성능 향상에 쏟을 시간이 많지 않다.

### memo를 일단 그냥 다 적용하는 방법

- 일단 memo로 감싸고 최적화 생각하기
- 잘못된 memo로 지불해야 하는 비용
  = props에 대한 얕은 비교가 발생하면서 지불해야하는 비용 (매우 적음)
- memo를 하지 않았을 때 발생할 수 있는 문제
  - 렌더링 함으로써 발생하는 비용
  - 컴포넌트 내부의 복잡한 로직 재실행
  - 위 두 가지가 모든 자식 컴포넌트에서 반복
  - 리액트가 구 트리와 신규 트리를 비교

⇒ memo를 하지 않았을 때 잠재적인 위험 비용이 더 크다.

### useMemo와 useCallback

의존성 배열을 비교하고 필요에 따라 값을 재계산하는 비용 vs. 함수를 매번 재생성하는 비용

- 리렌더링이 발생할 때 메모이제이션과 같은 별도 조치가 없다면 모든 객체는 재생성되고, 결과적으로 참조는 달라지게 된다. 특히 useEffect와 같은 의존성 배열에 쓰이면 참조가 계속 변경된다.
  ⇒ useMemo를 사용해서 불필요한 리렌더링을 막고 변하지 않는 고정값을 사용할 수 있다는 믿음을 줄 수 있다.
