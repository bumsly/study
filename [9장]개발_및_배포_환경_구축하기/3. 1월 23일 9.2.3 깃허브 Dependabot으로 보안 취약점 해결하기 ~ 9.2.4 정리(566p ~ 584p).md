요약 : 박운성

## 9.2.3 깃허브 Dependabot으로 보안 취약점 해결하기

- **Dependabot**
  - 깃허브에서 제공하는 강력한 기능 중 하나
  - 의존성에 문제가 있다면 이에 대해 문제를 알려주고 가능하다면 해결할 수 있는 풀 리퀘스트까지 열어준다.

### package.json의 dependencies 이해하기

- **유의적 버전 (semantic versioning)**
  - 버전은 **주.부.수**로 구성돼 있으며 각각의 정의는 다음과 같다.
  1. 기존 버전과 호환되지 않게 API가 바뀌면 "주(主) 버전"을 올리고,
  2. 기존 버전과 호환되면서 새로운 기능을 추가할 때는 "부(部) 버전"을 올리고,
  3. 기존 버전과 호환되면서 버그를 수정한 것이라면 "수(修) 버전"을 올린다.
  - **ex)** 16.0.0이라는 버전이 있다고 가정
    - 버전이 16.0.1이 됐다면 16.0.0에 존재하던 버그를 수정한 것이라고 볼 수 있다.
    - 만약 16.1.0이 됐다면 16.0.0에서 새로운 기능이 추가됐으며, 이 과정에서 기존 기능을 사용하는 방법은 바뀌지 않았다.
    - 17.0.0이 됐다는 것은 16.0.0과 호환되지 않도록 제공하는 API에서 무언가 변경이 일어난 것이다.
  - 이 외에 중요한 내용
    - 특정 버전으로 패키지를 배포하고 나면 그 버전의 내용은 절대 변경하지 말아야 한다. 변경사항이 있다면 반드시 새로운 버전으로 배포한다.
    - 주 버전 0 (0.y.z) 은 초기 개발을 위해 쓴다. 이 버전은 아무 때나 마음대로 바꿀 수 있다. 이 공개 API는 안정판으로 보지 않는 게 좋다. 대표적으로 Recoil이 있다.
      2022년 10월 기준 Recoil의 버전은 0.7.6이다. 만약 어느 날 0.8.0으로 버전이 올라갔다면 이는 기능이 추가된 것뿐만 아니라 API 스펙이 변경됐을 수도 있다. 그러므로 0으로 시작하는 실험 버전 라이브러리는 항상 사용할 때 주의를 기울여야 한다.
    - 수 버전 Z (x.y.Z | x > 0) 는 반드시 그 이전 버전 API와 호환되는 버그 수정의 경우에만 올린다. 버그 수정은 잘못된 내부 기능을 고치는 것이라 정의한다.
      만약 버그 수정이 API 스펙 변경을 동반한다면 반드시 주 버전을 올려야 한다. 만약 주 버전을 올리는 것이 껄끄럽다면 해당 API를 지원 중단(deprecated)으로 처리하고, 새로운 API를 만들어 부 버전을 올리는 것이 좋다.
  - **npm에서 주로 사용하는 버전 방식**
    - **react@16.0.0**: 버전 앞에 아무런 특수 기호가 없다면 정확히 해당 버전에 대해서만 의존하고 있다는 뜻이다.
    - **react@^16.0.0**: 16.0.0과 호환되는 버전을 의미한다. 호환된다는 뜻은 0보다 높은 부 버전에 대해서는 호환된다는 가정 하에 상위 버전을 설치할 수 있다는 것을 뜻한다. 즉, 여기서 가능한 버전은 16.0.0부터 17.0.0 미만의 모든 버전이다. 단, 앞서 언급한 것처럼 주 버전이 0인 경우에는 부 버전이 올라가도 API에 변경이 있을 수 있으므로 수 버전까지만 수용한다.
    - **react@~16.0.0**: 패치 버전에 대해서만 호환되는 버전을 의미한다. 즉, 여기서 가능한 버전은 16.0.0부터 16.1.0 미만의 모든 버전이다. 기능이 추가되는 수 버전은 사용하지 않는다.
  - **염두에 둬야 할 점**
    - **유의적 버전은 어디까지나 개발자들 간의 약속일 뿐, 정말로 해당 API의 버전이 이 유의적 버전에 맞춰 구현돼 있는지는 알 수 없다는 것이다.**
    - npm은 이에 대해 보증해 주지 않으며, 어디까지나 개발자 간의 암묵적인 약속일 뿐이다. 수 버전이 올라갔는데 기준 버전과 호환되지 않을 수도, 주 버전이 올라갔는데 변경된 사항이 전혀 없을 수도 있다.
    - 많은 개발자들이 이러한 버전에 대해 심혈을 기울여서 작업하고 있기 때문에 크게 걱정할 필요는 없지만 그럼에도 항상 버전을 올리거나 설정할 때는 주의를 기울여야 한다.
- **의존성 (dependencies)**
  - npm 프로젝트를 운영하는 데 필요한 자신 외의 npm 라이브러리를 정의해 둔 목록이다.
  - **dependencies**
    - package.json에서 npm install을 실행하면 설치되는 의존성이며, npm install 패키지명을 실행하면 dependencies에 추가된다.
    - 해당 프로젝트를 실행하는 데 꼭 필요한 패키지가 여기에 선언된다.
  - **devDependencies**
    - package.json에서 npm install을 실행하면 설치되는 의존성이며, npm install 패키지명 --save-dev를 실행하면 devDependencies에 추가된다.
    - 해당 프로젝트를 실행하는 데는 필요하지 않지만 개발 단계에서 필요한 패키지들을 여기에 선언한다.
  - **peerDependencies**
    - 주로 서비스보다는 라이브러리와 패키지에서 자주 쓰이는 단위다.
    - 이는 직접적으로 해당 패키지를 require하거나 import하지는 않지만 호환성으로 인해 필요한 경우를 의미한다.
    - 만약 재사용 가능한 훅을 제공하는 패키지를 만든다고 가정해 보자.
      이 경우 실제 react를 import하는 일은 경우에 따라 없을 수도 있지만 사용하려면 리액트 16.8.6 버전 이상이 필요하다.
      단순히 useCounter를 제공한다고 해서 쓸모 있는 것이 아니라, 리액트훅을 제공하는 버전을 설치한 서비스에서 사용해야만 올바르게 사용할 수 있을 것이다.
      이 경우 다음과 같이 peerDependencies를 선언하면 된다.
          ```jsx
          {
            "peerDependencies": {
              "react": ">=16.8",
              "react-dom": ">=16.8"
            }
          }
          ```
  - **예시**
    - 리액트 애플리케이션을 예로 들어보자.
    - react, react-dom, next 등은 실행에 반드시 필요한 패키지이므로 dependencies에 선언한다.
    - eslint, jest, typescript 등은 실행에는 필요하지 않은, 개발 단계에서만 필요한 패키지이므로 devDependencies에 선언한다.
  - 최근에는 애플리케이션 실행에 필요한 패키지를 구분하는 것에 의문을 제기하는 목소리도 있다.
    1. **번들러의 존재**
       ⇒ 실제 서비스에 배포해야 하는 라이브러리인지를 결정하는 것은 번들러다.
       번들러가 코드의 시작점에서부터 각 파일 간의 종속성을 판단한 다음, 필요한 파일을 빌드 과정을 거쳐 하나의 결과물로 만든다.
       dependencies와 devDependencies 간의 차이가 애플리케이션 최종 결과물에는 전혀 영향을 미치지 않는 것이다.
    2. **복잡해진 개발 파이프라인**
       ⇒ 과거와 현재의 전략이 달라져서 (typescript 등) dependencies와 devDependencies의 경계가 적어도 프런트엔드 애플리케이션의 경우에는 모호해지고 있다.
       그래서 일부 프로젝트를 보면 둘을 구분하지 않고 모두 dependencies에 몰아넣고 관리하는 경우도 있다.
  - dependencies와 devDependencies의 구분이 완전히 무의미한 것은 아니다.
    - npm에 업로드할 패키지를 개발한다면 이러한 두 의존성의 구분은 매우 중요해진다 (dependencies에 있는 패키지들만 모두 최종 패키지 결과물에 포함되게 해야 한다).
    - 개발자가 프런트엔드 서비스를 위해 package.json을 작성하고 관리한다면 dependencies에 모두 넣는 것은 크게 문제가 되지 않지만 향후 다른 패키지의 의존성을 읽거나 출시하는 데 도움이 되려면 이 둘의 차이를 분명히 알고 있어야 한다.

### Dependabot으로 취약점 해결하기

- **프로젝트 준비**
  ```json
  package.json

  {
    "name": "danger-react-app",
    "version": "0.1.0",
    "private": true,
    "dependencies": {
      "axios": "^0.19.0",
      "mobx": "^5.11.0",
      "mobx-react-lite": "^1.4.1",
      "react": "^16.8.6",
      "react-dom": "^5.0.1",
      "react-scripts": "^3.4.1",
      "react-swipeable-views": "^0.13.3"
    },
    "scripts" {
      "start": "react-scripts start",
      "build": "react-scripts build",
      "test": "react-scripts test",
      "eject": "react-scripts eject"
    },
    "browserslist":{
      "production": [">0.2%", "not dead", "not op_mini all"],
      "development": [
        "last 1 chrome version",
        "last 1 firefox version",
        "last 1 safari version"
      ]
    }
  }
  ```
  - 이 package.json을 기준으로 설치하면 설치만 했을 뿐인데, 각종 vulnerabilities를 발견했다는 영 좋지 않아 보이는 메시지가 눈에 띈다.
  - 깃허브에서 이를 탐지하는 것을 확인하기 위해 원격 저장소에 푸시해 보자.
  - 원격 저장소를 확인해 보면 Dependabot이 저장소의 의존성에 여러 가지 문제가 있다고 알려준다.
  - 그리고 배너의 ‘See Dependabot alerts’를 누르면 구체적으로 어떤 의존성에 문제가 있는지 확인할 수 있다.
  - 이 패키지를 사용했던 당시에는 문제가 없는 패키지였을 수도 있지만 시간이 지나면서 보안 취약점이 하나둘씩 발견되는 것이 바로 빌드해서 배포하기엔 왠지 모르게 조금 위험해 보인다.
- **개별 취약점 살펴보기**
  - 깃허브의 Dependabot은 취약점을 Critical, High, Moderate, Low의 4단계로 분류한다. (Critical의 심각도가 가장 높음)
  - 취약점에 대한 상세 정보 페이지
    1. 취약점을 발견한 파일의 경로
       ⇒ dependencies에 직접 명시한 경우 package.json이 발견되는 경우도 있음
       ⇒ dependencies가 의존하고 있는 패키지에서 발견되는 경우 package-lock.json이 명시된다.
    2. 취약점을 바로 수정할 수 있는 경우 표시되는 버튼
       ⇒ Dependabot은 패키지의 취약점을 수정할 수 있다면 풀 리퀘스트도 생성해 준다.
       ⇒ 모든 취약점에 대해 풀 리퀘스트가 생성되는 것은 아니다.
       ⇒ 수정이 불가능하다고 판단하는 경우 취약점만 알려준다.
    3. 보안 취약점의 심각도
       ⇒ CVE란 ‘Common Vulnerabilities and Exposures’의 약자로, 공개적으로 알려진 컴퓨터 보안 결함 목록을 나타낸다.
    4. 취약점의 자세한 정보
       ⇒ 어떤 패키지가 취약점으로 지정됐는지, 현재 사용 중인 버전은 무엇이며, 어느 버전을 설치해야 해결할 수 있는지, 그리고 해당 취약점이 발생하는 사황과 조심해야 할 것들을 나타낸다.
  - 패키지의 설치 경로를 확인하는 명령어
    - npm ls [패키지 이름]
    - npm ls는 ‘list installed packages’라는 뜻으로 설치된 패키지가 왜 어떤 의존성 때문에 설치됐는지 확인할 수 있는 명령어
  - 이러한 방법을 활용해 문제 패키지가 왜 문제가 되는지 파악해 볼 수 있다.
  - 직접적으로 영향이 없을 것으로 판단되는 패키지에 대해서는 시급성을 낮춰서 대응하는 것이 좋다.
  - react-scripts를 사용하다 보면 유독 취약점 관련 경고가 많은 것을 느낄 수 있는데, 그 이유는 리액트 팀이 실제 취약점이 있는 패키지를 사용한다 하더라도 실제 개발자에게 미칠 수 있는 영향이 없는 경우에는 취약점을 긴급하게 수정하지 않겠다고 선언했기 때문이다.
- **취약점 해결하기**
  - Dependabot이 풀 리퀘스트를 열어준 경우 가장 쉽게 해결할 수 있다.
  - 풀 리퀘스트로 손쉽게 해결할 수 없는 경우
    - 해당 패키지를 의존하는 다른 패키지의 버전을 올리기
    - 패키지 내부에 선언된 해당 패키지의 의존성을 강제로 올리기
      - npm이 제공하는 overrides를 활용
- **정리**
  - 의존성 관련 이슈를 방지하는 가장 좋은 방법은 의존성을 최소한으로 유지하는 것
  - 가능한 한 내재화할 수 있는 모듈은 내재화하고, 의존성을 최소한으로 유지하는 것이 좋다.
  - 의존성을 최소화할 수 없다면, 내재화할 수 있는 모듈이 많지 않다면 가능한 한 널리 알려져 있고 많은 사람들이 사용하는, 그리고 활발하게 유지보수되는 패키지를 사용해야 한다.
  - Dependabot이 경고하는 문제에 대해 계속해서 관심을 가져야 한다.
  - 깃허브 Dependabot은 이슈를 찾는 용도로만 사용하고, 절대로 완벽하게 수정해 준다고 맹신해서는 안 된다.
  - 깃허브 Dependabot으로 수정하기 어려운 이슈라면 npm의 overrides를 적극 활용해 보자.

## 9.2.4 정리

- 깃허브는 단순히 코드 저장소의 기능뿐만 아니라 **Dependabot, Copilot, GitHub Pages** 등 개발자에게 도움이 될만한 다양한 기능을 제공한다.
- 깃허브는 코드 관리 전반에 걸친 다양한 서비스를 제공하므로 기회가 된다면 다양한 깃허브 도구를 활용해 코드를 관리해보자.
